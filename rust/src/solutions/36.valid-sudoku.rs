/*
 * @lc app=leetcode.cn id=36 lang=rust
 * @lcpr version=30204
 *
 * [36] 有效的数独
 *
 * https://leetcode.cn/problems/valid-sudoku/description/
 *
 * algorithms
 * Medium (64.22%)
 * Likes:    1383
 * Dislikes: 0
 * Total Accepted:    544K
 * Total Submissions: 839.8K
 * Testcase Example:  '[["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]'
 *
 * 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
 *
 *
 * 数字 1-9 在每一行只能出现一次。
 * 数字 1-9 在每一列只能出现一次。
 * 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
 *
 *
 *
 *
 * 注意：
 *
 *
 * 一个有效的数独（部分已被填充）不一定是可解的。
 * 只需要根据以上规则，验证已经填入的数字是否有效即可。
 * 空白格用 '.' 表示。
 *
 *
 *
 *
 * 示例 1：
 *
 * 输入：board =
 * [["5","3",".",".","7",".",".",".","."]
 * ,["6",".",".","1","9","5",".",".","."]
 * ,[".","9","8",".",".",".",".","6","."]
 * ,["8",".",".",".","6",".",".",".","3"]
 * ,["4",".",".","8",".","3",".",".","1"]
 * ,["7",".",".",".","2",".",".",".","6"]
 * ,[".","6",".",".",".",".","2","8","."]
 * ,[".",".",".","4","1","9",".",".","5"]
 * ,[".",".",".",".","8",".",".","7","9"]]
 * 输出：true
 *
 *
 * 示例 2：
 *
 * 输入：board =
 * [["8","3",".",".","7",".",".",".","."]
 * ,["6",".",".","1","9","5",".",".","."]
 * ,[".","9","8",".",".",".",".","6","."]
 * ,["8",".",".",".","6",".",".",".","3"]
 * ,["4",".",".","8",".","3",".",".","1"]
 * ,["7",".",".",".","2",".",".",".","6"]
 * ,[".","6",".",".",".",".","2","8","."]
 * ,[".",".",".","4","1","9",".",".","5"]
 * ,[".",".",".",".","8",".",".","7","9"]]
 * 输出：false
 * 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在,
 * 因此这个数独是无效的。
 *
 *
 *
 * 提示：
 *
 *
 * board.length == 9
 * board[i].length == 9
 * board[i][j] 是一位数字（1-9）或者 '.'
 *
 *
 */

// @lcpr-template-start
use crate::Solution;
// @lcpr-template-end
// @lc code=start
impl Solution {
    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {
        let mut rows = vec![vec![false; 9]; 9];
        let mut cols = vec![vec![false; 9]; 9];
        let mut boxs = vec![vec![vec![false; 9]; 3]; 3];

        for i in 0..9 {
            for j in 0..9 {
                if board[i][j] == '.' {
                    continue;
                }

                let num = (board[i][j] as u8 - b'1') as usize;

                if rows[i][num] || cols[j][num] || boxs[i / 3][j / 3][num] {
                    return false;
                }

                rows[i][num] = true;
                cols[j][num] = true;
                boxs[i / 3][j / 3][num] = true;
            }
        }

        true
    }
}
// @lc code=end

/*
// @lcpr case=start
// [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\n
// @lcpr case=end

// @lcpr case=start
// [["8","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]\n
// @lcpr case=end

 */

#[cfg(test)]
mod tests {
    use super::*;

    /// 辅助函数：将字符串数组转换为 Vec<Vec<char>>
    fn to_board(input: &[&[&str; 9]; 9]) -> Vec<Vec<char>> {
        input
            .iter()
            .map(|row| row.iter().map(|s| s.chars().next().unwrap()).collect())
            .collect()
    }

    #[test]
    fn test_example_1() {
        // 示例1：有效的数独
        let board = to_board(&[
            &["5", "3", ".", ".", "7", ".", ".", ".", "."],
            &["6", ".", ".", "1", "9", "5", ".", ".", "."],
            &[".", "9", "8", ".", ".", ".", ".", "6", "."],
            &["8", ".", ".", ".", "6", ".", ".", ".", "3"],
            &["4", ".", ".", "8", ".", "3", ".", ".", "1"],
            &["7", ".", ".", ".", "2", ".", ".", ".", "6"],
            &[".", "6", ".", ".", ".", ".", "2", "8", "."],
            &[".", ".", ".", "4", "1", "9", ".", ".", "5"],
            &[".", ".", ".", ".", "8", ".", ".", "7", "9"],
        ]);
        assert_eq!(Solution::is_valid_sudoku(board), true);
    }

    #[test]
    fn test_example_2() {
        // 示例2：无效的数独（左上角3x3宫内有两个8）
        let board = to_board(&[
            &["8", "3", ".", ".", "7", ".", ".", ".", "."],
            &["6", ".", ".", "1", "9", "5", ".", ".", "."],
            &[".", "9", "8", ".", ".", ".", ".", "6", "."],
            &["8", ".", ".", ".", "6", ".", ".", ".", "3"],
            &["4", ".", ".", "8", ".", "3", ".", ".", "1"],
            &["7", ".", ".", ".", "2", ".", ".", ".", "6"],
            &[".", "6", ".", ".", ".", ".", "2", "8", "."],
            &[".", ".", ".", "4", "1", "9", ".", ".", "5"],
            &[".", ".", ".", ".", "8", ".", ".", "7", "9"],
        ]);
        assert_eq!(Solution::is_valid_sudoku(board), false);
    }

    #[test]
    fn test_empty_board() {
        // 边界情况：全空的数独是有效的
        let board = to_board(&[
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
        ]);
        assert_eq!(Solution::is_valid_sudoku(board), true);
    }

    #[test]
    fn test_duplicate_in_row() {
        // 边界情况：同一行有重复数字
        let board = to_board(&[
            &["1", "1", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
        ]);
        assert_eq!(Solution::is_valid_sudoku(board), false);
    }

    #[test]
    fn test_duplicate_in_column() {
        // 边界情况：同一列有重复数字
        let board = to_board(&[
            &["1", ".", ".", ".", ".", ".", ".", ".", "."],
            &["1", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
        ]);
        assert_eq!(Solution::is_valid_sudoku(board), false);
    }

    #[test]
    fn test_duplicate_in_box() {
        // 边界情况：同一个3x3宫内有重复数字
        let board = to_board(&[
            &["1", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", "1", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
            &[".", ".", ".", ".", ".", ".", ".", ".", "."],
        ]);
        assert_eq!(Solution::is_valid_sudoku(board), false);
    }
}
